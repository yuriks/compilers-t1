// This regexp is used before reading a new token to skip whitespace
@@skip := [ \t\n]*

// Token names start with @
@id := [a-zA-Z][a-zA-Z0-9_]*
@int-literal := [0-9]+
@float-literal := [0-9]+(\.[0-9]+)f

// 'foo' defines a token matching the literal string 'foo' (no regexp)
// which is internally translated to token name @$foo
type := 'int' | 'float' ;
value := @int-literal | @float-literal | @id ;
rel-op := '==' | '!=' | '<' | '>' | '<=' | '>=' ;

// -> means "may follow", aka, backtracking is possible
// => immediatelly aborts if the match fails, and prevents backtracking
stmt-var-decl := @id -> ':' => type => initialization? ;
initialization := ':=' => value ;

stmt-assignment := @id -> ':=' => value ;

comparsion := value => rel-op => value ;
stmt-if := 'if' => comparsion => ':' => block ;
block := statement* => @end ;

// The rule which name starts with # is taken as the root rule
#statement := ( stmt-var-decl | stmt-assignment | stmt-if ) => ';' ;
